(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[2,75],{

/***/ 12:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aggregateDefIdToLabel", function() { return aggregateDefIdToLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyProperties", function() { return copyProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCodeList", function() { return getCodeList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchImport", function() { return batchImport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslationsForList", function() { return getTranslationsForList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModuleId", function() { return getModuleId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModuleVariables", function() { return getModuleVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchRequestHelper", function() { return batchRequestHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadingOverlay", function() { return loadingOverlay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertReferencesToAssocArray", function() { return convertReferencesToAssocArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSingleAccordionPanel", function() { return addSingleAccordionPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFormElements", function() { return createFormElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bookmark", function() { return bookmark; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollToElement", function() { return scrollToElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAccordion", function() { return addAccordion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAgreementsStatus", function() { return getAgreementsStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVariableDefinition", function() { return createVariableDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReferenceTableListId", function() { return getReferenceTableListId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponentDefinition", function() { return getComponentDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertJsonToObjects", function() { return convertJsonToObjects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareFilter", function() { return prepareFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processAttributeValues", function() { return processAttributeValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleSelectWithSpecifyComponentData", function() { return handleSelectWithSpecifyComponentData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attributeValuesToHtml", function() { return attributeValuesToHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGeomField", function() { return parseGeomField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReferenceTableKeyLabel", function() { return getReferenceTableKeyLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCodeListValue", function() { return getCodeListValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCodeListValueFromId", function() { return getCodeListValueFromId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateVariableKeys", function() { return translateVariableKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupAttributesByModule", function() { return groupAttributesByModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRefCodeListValues", function() { return getRefCodeListValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateConditionsForCompleteButton", function() { return validateConditionsForCompleteButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moduleHeader", function() { return moduleHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipAttributes", function() { return skipAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generalTableRecordsOptions", function() { return generalTableRecordsOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortVariables", function() { return sortVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moduleVariablesTableRecordsOptions", function() { return moduleVariablesTableRecordsOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRefValuesKey", function() { return getRefValuesKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filePath", function() { return filePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveButtonHelper", function() { return saveButtonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCenik", function() { return parseCenik; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findObjectPriceList", function() { return findObjectPriceList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignRequestCallbackToasters", function() { return assignRequestCallbackToasters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestCallbacksHelper", function() { return requestCallbacksHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateKey", function() { return translateKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReferences", function() { return getReferences; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestHelper", function() { return requestHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alertCode", function() { return alertCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dmgGetPriceListIndex", function() { return dmgGetPriceListIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dmgGetWorkHourPrices", function() { return dmgGetWorkHourPrices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testData", function() { return testData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateVTV", function() { return updateVTV; });
/* harmony import */ var _app_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);



const aggregateDefIdToLabel = (data, id) => {
    const adef = data.find(d => d.id == id);
    return adef ? adef.label + ": " + adef.description : ''
}

/**
 * Copies properties from sourceObject to targetObject
 * 
 * @param {object} targetObject 
 * @param {object} sourceObject 
 * @param {array<string>} properties list of properties to copy from sourceObject to targetObject
 */

const copyProperties = (targetObject, sourceObject, properties) => {
    properties.map(p => targetObject[p] = sourceObject[p]);
}  

/**
 * Calls mbase2 API to retrieve code list values
 * 
 * @param {string|array} listLabel list key label or array of key labels of code list values to retrieve
 * @param {string} apiRoot 
 * @param {array} keys aray of keys to retrieve from database - if empty all keys for the specific code list will be returned
 */
const getCodeList = async (listLabel, apiRoot=_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot, keys = []) => {
    if (!Array.isArray(listLabel)) listLabel = [listLabel];
    const u = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const _keys = keys.length === 0 ? '' : `&:key=(${keys.join(',')})`
    const res = await u.request(apiRoot + 
        `/code_list_options?:list_key=(${listLabel.join(',')})${_keys}`);
    
    res.map(r => {
        r.translations = (r.translations && u.jsonParse(r.translations)) || {}
    });

    return res;
}

/**
 * 
 * @param {object} imports 
 * @param {object} imports.batch batch.js module 
 * @param {object} imports.ModalDialog ModalDialog module
 */

const batchImport = async (imports, moduleKey, dialogTitle = null, batchImportOptions = null) => {
    const batch = imports.batch;
    const modal = new imports.ModalDialog.default();

    modal.$title.text(dialogTitle || moduleKey);

    //TransformImportData
    
    const allModuleAttributes = await getModuleVariables(moduleKey);

    console.log('allModuleAttributes', allModuleAttributes);

    const attributes = allModuleAttributes.filter(a => a.importable === true).filter(a => ['_species_name', '_uname', '_batch_id', '_location'].indexOf(a.key_name_id)===-1);
    const refValues = await getRefCodeListValues(attributes);

    const batchModel = {
        [moduleKey]: attributes
    };

    
    batch.default(Object.assign({
        $parent: modal,
        model: batchModel,
        tableName: moduleKey,
        refValues: refValues,
        modal:modal
    }));
    
    modal.show();
}

const getTranslationsForList = async (listKey) => {
    if (_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].translations[listKey]) return _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].translations[listKey];

    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));

    const res = await requestHelper(_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot + '/code_list_options?:__filter=[["list_key","=","'+listKey+'"]]');
    const rval = {};

    const lang = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language;

    for (const item of res) {
        
        if (item.translations) {
            item.translations = utils.jsonParse(item.translations);
        }

        rval[item.key] = (item.translations && item.translations[lang]) || item.key; 
    }

    _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].translations[listKey] = rval;

    return rval;
}

const getModuleId = async key => {
    const codeList = await getCodeList('modules', _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot);
    return codeList.find(cl => cl.key === key).id;
}

/**
 * Returns variables for the moduleId
 * 
 * @param {integer} moduleId 
 */
const getModuleVariables = async (moduleId, sort = true, splitRequiredOptional=false, skipDefault=true) => {
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const batchCalls = [];

    if (skipDefault === false) {
        batchCalls.push(`module_variables/language/${_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language}?:module_id:code_list_options/key=__default_module`);
    }
    
    batchCalls.push(moduleId === parseInt(moduleId) ? `module_variables/language/${_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language}?:module_id=${moduleId}` : `module_variables/language/${_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language}?:module_id:code_list_options/key=${moduleId}`);

    const variables = await batchRequestHelper(batchCalls);

    if (skipDefault===true) {
        variables.unshift([]);
    }

    if (sort) {
        return [...sortVariables(variables[0], splitRequiredOptional), ...sortVariables(variables[1], splitRequiredOptional)];
    }
    else {
        return [...variables[0], ...variables[1]];
    }
}

const batchRequestHelper = (batchCalls) => {

    const promisses = [];
    for (const batchCall of batchCalls) {
        if (batchCall) {
            promisses.push(requestHelper(_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot + '/' + batchCall));
        }
        else {
            promisses.push([]);
        }
    }
    return Promise.all(promisses);
}

const loadingOverlay = (show, $el) => {
    const action = show ? 'show' : 'hide';
    
    if ($ && $.LoadingOverlay) {
        if ($el) {
            $el.LoadingOverlay(action);
        }
        else {
            $.LoadingOverlay(action);
        }
    }
}

const convertReferencesToAssocArray = async (refValues) => {
    let codeListValues, tableReferences;

    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));

    if (refValues) {
        codeListValues = refValues.codeListValues;
        tableReferences = refValues.tableReferences;
        codeListValues = codeListValues && utils.convertToAssocArray(codeListValues);
        tableReferences = tableReferences && utils.convertToAssocArray(tableReferences,'_id_list_id');
    }

    return {codeListValues, tableReferences};
}

/**
 * 
 * @param {object} cm ComponentManager
 * @param {object} exports exports.js module
 * @param {string} title 
 * @param {string} key 
 * @param {DOM object} $parent 
 * @param {string} preposition preposition to be added to key
 */

async function addSingleAccordionPanel (cm, exports, title, key, $parent, preposition = 'acc_', returnPanelObject = false, options = {}) {
    const def = {key: preposition + key, $parent: $parent, component: (await exports.Accordion()).default, options: Object.assign(exports.componentsOptions.accordion([title]), options)};
    const cnt = await cm.add(def);
    return returnPanelObject ? cnt.panels[0] : cnt.panels[0].$body;
}

async function createFormElements(cm, $parent, attributes, refValues={}) {
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));

    attributes = utils.convertToAssocArray(attributes, 'key_name_id');
    
    const {componentDefinitions, definitionAliases} = (await __webpack_require__.e(/* import() */ 3).then(__webpack_require__.bind(null, 14)));

    const exports = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 7));

    const importDefinitions = componentDefinitions(exports);
    const aliases = definitionAliases(utils.patterns);

    cm = cm || new (await exports.ComponentManager()).default();
    
    for (const key of Object.keys(attributes)) {
        const v = attributes[key];
        if (v.visible===false) continue;
        const cdef = await getComponentDefinition(v, importDefinitions, aliases, refValues, true, $parent);
        cdef.key = key;
        cdef.$parent = $parent;
        const cmp = await cm.add(cdef);
        if (v._component && v._component.onComponentAdded) v._component.onComponentAdded(cmp);
    };

    return cm;
}

const bookmark = (op) => {
    return $(`<div class="bookmark bookmark-${op.required ? 'required' : 'optional' }">
        ${op.title ? `<h5>${op.title}${op.required === false ? '' : '*'}</h5>` : op.content}
    </div>`);
}

const scrollToElement = ($target, $scrollContainer, topOffset = 10) => {

    const $parent = $scrollContainer || $target.parent();
    
    const parent = $parent[0];
    const target = $target[0];

    $parent.scrollTop(0);

    const parentRect = parent.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    $parent.scrollTop(targetRect.top - parentRect.top);
}

async function addAccordion (cm, exports, titles, key, $parent, preposition = 'acc_') {
    const def = {key: preposition + key, $parent: $parent, component: (await exports.Accordion()).default, options: exports.componentsOptions.accordion(titles)};
    const cnt = await cm.add(def);
    return cnt.panels.map(p => p.$body);
}

/**
 * Number of completed agreements by claim_id
 * @param {*} result 
 * @returns {object}
 */

function getAgreementsStatus(result) {
    const agreementsStatus = {};

    result.map(row => {
        if (!agreementsStatus[row._claim_id]) agreementsStatus[row._claim_id] = 0;
        
        if (row._completed === true) {
            agreementsStatus[row._claim_id] += 1;
        }
    });

    return agreementsStatus;
}

/**
 * 
 * @param {string} key usaually database table column name
 * @param {string} label translation for key - this label is shown e.g. in datatables column
 * @param {string} dataType integer, text, real, table_reference, code_list_reference, ...
 * @param {string} [ref=null] reference to table or code_list (used when dataType is table_reference or code_list_reference)
 */
function createVariableDefinition(key, label, dataType, ref = null) {
    return {
        key_name_id: key,
        t_name_id: label,
        key_data_type_id: dataType,
        ref: ref
    }
}

/**
 * 
 * @param {*} labelKey 
 * @param {array} variablesAttributes 
 * @returns 
 */
function getReferenceTableListId(labelKey, variablesAttributes) {
    const v = variablesAttributes.find(v => v.key_ref === labelKey);
    return v ? v.ref : null;
}

/**
 * Gets a component definition suitable for appending via ComponentManager.add function
 * @param {*} variableAttributes 
 * @param {*} importDefinitions component defintioons
 * @param {*} aliases subtype aliases (cf. definitionAliases in componentDefinitions.js)
 * @param {*} references code list options and table references (for the variableAttributes of the corresponding type)
 * @param {*} load if true components are loaded before returning
 * @param {*} $container used when $container has to be passed as an option of the component - callback is handled in the `componentDefinitions.js` file
 */
const getComponentDefinition = async (variableAttributes, importDefinitions, aliases, references = {}, load = true, $container = null) => {

    /**helper function */
    function getAliasOptions(dataType) {
        const alias = aliases[dataType];
        
        let aliasOptions = null;
        let cdef = null;

        if (alias) {
            cdef = importDefinitions[alias.base];
            if (alias.op) {
                aliasOptions = alias.op;
            }   //component options overrides
        }

        return {aliasOptions, cdef};
    }
    
    const dataType = variableAttributes.key_data_type_id;

    let cdefOverride = null;
    let aliasOptions = null;

    let cdef = importDefinitions[dataType];

    if (variableAttributes._component) {
        if (variableAttributes._component.default !== true) {
            
            cdefOverride = Object.assign({}, variableAttributes._component);
            
            if (variableAttributes._component.defaultOptions) {
                if (!cdef) {
                    ({aliasOptions, cdef} = getAliasOptions(dataType));//destructure to an already declared variable:
                }
                cdefOverride = Object.assign(cdefOverride, cdef);
                cdefOverride.import = variableAttributes._component.import;
            }

            cdef = cdefOverride;
        }
    }
    
    if (!cdef) {
        ({aliasOptions, cdef} = getAliasOptions(dataType));//destructure to an already declared variable:
    }

    if (cdef) {
        
        let _op = variableAttributes._op || {};
        
        const refValuesKey = getRefValuesKey(variableAttributes);

        if (refValuesKey) { //this is true only for data types code_list_reference and table_reference
            _op = {
                data: {
                    values: references[refValuesKey]
                }
            }
        }

        let componentDefinition = {};
        if (cdef.componentDefinition) {
            
            let imports = null;
            if (cdef.imports) {
                imports = await cdef.imports();
            }
            
            componentDefinition = cdef.componentDefinition(variableAttributes, _op, imports, $container); 
        }

        if (componentDefinition.options && componentDefinition.options.pattern) {
            const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
            componentDefinition.options.pattern = utils.patterns[componentDefinition.options.pattern];
            if (variableAttributes.t_pattern_id && !componentDefinition.options.help) {   //if helper text is not already defined by some other means - this is currently always false
                componentDefinition.options.help = variableAttributes.t_pattern_id || variableAttributes.key_pattern_id;
            }
        }

        if (load === true) {
            const cimp = await cdef.import();
            componentDefinition.component = cimp[componentDefinition.component || 'default'];
        }

        if (aliasOptions) {
            componentDefinition.options = Object.assign(componentDefinition.options, aliasOptions);
        }

        if (variableAttributes._component && variableAttributes._component.additionalComponentOptions) {
            componentDefinition.options = Object.assign(componentDefinition.options || {}, variableAttributes._component.additionalComponentOptions);
        }

        return componentDefinition;
    }

    return null;
}

/**
 * 
 * @param {array<object>} res array of associative arrays where keys are attribute names
 * @param {array<objects>} attributes variable definitions
 */

const convertJsonToObjects = (res, attributes) => {
    const jsonAttributes = [];
    attributes.map(a => {
        if (['json', 'jsonb', 'table_reference_array', 'code_list_reference_array', 'location_data_json'].indexOf(a.key_data_type_id) !== -1) {
            jsonAttributes.push(a.key_name_id);
        }
    });

    if (jsonAttributes.length === 0) return;

    res.map(r => {
        jsonAttributes.map(a => {
            r[a] = r[a] && JSON.parse(r[a]);
        })
    });
}

/**
 * Replace quotes in filter expression to be parsable by PHP json_decode function
 * 
 * @param {array<array>} filter 
 */

const prepareFilter = (filter, escapeDoubleQuotes=true) => {
    
    if (filter.length === 0) return '';

    filter = JSON.stringify(filter);
    
    if (escapeDoubleQuotes === true) {
        filter = filter.replace(/"/g,'\\"');
    }
    
    return `?:__filter=${filter}`;
}

/**
 * Translates attributes values
 * @param {object} row 
 * @param {object} attributesKeyed 
 */

const processAttributeValues = (row, attributesKeyed, refValuesKeyed) => {
    Object.keys(row).map(cname => {
        const v = attributesKeyed[cname];
        if (v && row[cname]!==undefined) {

            const refValuesKey = getRefValuesKey(v);

            if (refValuesKey) {
                let values = row[cname];
                if (!Array.isArray(values)) {
                    values = [values];
                }

                const labels = values.map(value => {
                    const key = refValuesKey === 'tableReferences' ? value + '_' + v.ref : value;
                    return value ? getCodeListValue(key, refValuesKeyed[refValuesKey], _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language) : value;
                });
                
                row['t_' + cname] = labels.join('<br>');
            }
            else if (v.key_data_type_id === 'location_reference') {
                row['t_' + cname] = row['geom'];

                const geom = JSON.parse(row['geom']);
                row[cname] = {
                    id: row[cname],
                    lat: geom.coordinates[1],
                    lon: geom.coordinates[0]
                }
            }
            else if (v.key_data_type_id === 'boolean') {
                //row[cname] = `<input type="checkbox" ${row[cname] ? 'checked' : ''}>`;
                if (row[cname]===true || row[cname]===false) {
                    row[cname] = row[cname] === true ? _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].t`DA` : _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].t`NE`;
                }
            }
        }
    });
}

/**Handle saving SelectWithSpecify component data*/
const handleSelectWithSpecifyComponentData = (request, cm) => {

    Object.keys(cm.model.attributes).map(key => {
        const attr = cm.model.attributes[key];
        const value = request.attributes[':'+key];
        if (value !== undefined &&
            (attr.key_data_type_id === "code_list_reference" || attr.key_data_type_id === "code_list_reference_array")) {
                if (value && value.specify!==undefined) {
                    request.attributes[':'+key] = value.select;
                    request.attributes[':_data'] = Object.assign(request.attributes[':_data'] || {},{[key]:value.specify});
                }
                else {
                    if (request.attributes[':_data'] && request.attributes[':_data'][key]) delete request.attributes[':_data'][key];
                }
        }
    });
}

const attributeValuesToHtml = (row, attributesKeyed, delimiter = '<br>', attributeKeysToInclude = [], skipEmpty = true, refValues = {}, skip=[]) => {
    const output = [];
    const attributeKeysToIncludeSet = new Set(attributeKeysToInclude);

    const attributes = Object.values(attributesKeyed);

    for (let key of attributeKeysToIncludeSet) {
        if (skip.indexOf(key)!==-1) continue;
            const a = attributesKeyed[key];
            if (a) {
                const tkey = 't_'+key; //translation key (API automatically returns translations for the selected language for the base database tables but not for the views)
                let value = row[tkey] || row[key];
                if (skipEmpty && !value) continue;
                if (!row[tkey]) {//if translation is missing we get it from the attribute definition
                    if (a.key_data_type_id === 'table_reference') {
                        value = getReferenceTableKeyLabel(value, a.key_ref, attributes, refValues)
                    }
                    else if (a.key_data_type_id === 'code_list_reference') {
                        value = getCodeListValueFromId(value, refValues, _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language);
                    }
                    else if (a.key_data_type_id === 'table_reference_array') {
                        const translatedValues = [];
                        value = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["jsonParse"])(value || []);
                        for (const v of value) {
                            if (skipEmpty && !v) continue;
                            translatedValues.push(getReferenceTableKeyLabel(v, a.key_ref, attributes, refValues));
                        }
                        value = translatedValues.join(', ');
                    }
                } 
                const label =  a.t_name_id || a.key_name_id;
                output.push(`<b>${label}:</b> ${value}`);
            }
            else {
                const value = row[key];
                if (skipEmpty && !value) continue;
                output.push(`<b>${key}:</b> ${value}`);
            }
    };
    
    return output.join(delimiter);
}

const parseGeomField = (row, key='_location_reference') => {
    if (!row.geom) return;
    const geom = JSON.parse(row['geom']);
    row[key] = {
        id: row[key],
        lat: geom.coordinates[1],
        lon: geom.coordinates[0]
    }
}

/**
 * 
 * @param {*} id 
 * @param {*} refTableName 
 * @param {*} variables 
 * @param {*} refValues 
 * @returns 
 */

const getReferenceTableKeyLabel = (id, refTableName, variables, refValues) => {
    const listId = getReferenceTableListId(refTableName, variables);
    if (listId) {
        const option = refValues.tableReferences.find(item => item.list_id == listId && item.id == id);
        if (option) {
            return option.key;
        }
    }
    return id;
}

const getCodeListValue = (key, refValues, language = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language) => {
    const row = refValues && refValues[key];
    if (!row) return key;
    const values = row.translations;
    if (!values) return row.key;
    const value = values[language];
    if (!value) return row.key;
    return value;
}

/**
 * 
 * @param {integer} id code_list_options id
 * @param {object} refValues {codeListValues{array}}
 * @param {string} language 
 * @returns 
 */

const getCodeListValueFromId = (id, refValues, language) => {
    const row = refValues.codeListValues.find(clval => clval.id == id);
    return getCodeListValue(id, {[id]: row}, language);
}

/**
 * 
 * @param {*} obj 
 * @param {object} values associative array of keys with translations (these are variabledDefinitions if language is not defined and code list values if language is defined)
 * @param {*} language 
 */
const translateVariableKeys = (obj, values, language = null) => {
    const res = {};
    const keyMap = {};
    
    Object.keys(obj).map(key => {
        let nkey = null;
        if (language) {
            nkey = (values[key] && values[key].translations[language]) || key; 
            res[nkey] = obj[key];
        }
        else {
            nkey = (values[key] && values[key].t_name_id) || key; 
            res[nkey] = obj[key];
        }
        keyMap[key] = nkey;
    });
    
    return {
        translated: res,
        keyMap: keyMap
    };
}

const groupAttributesByModule = references => {
    if (!references) return references;

    const res = {};

    references.map(r => {
        if (!res[r.key_module_id]) res[r.key_module_id] = [];
        res[r.key_module_id].push(r);
    });

    return res;
}

/**
 * Gets code lists for ref properties in the attributes argument. If reference in attributes array is passed as a table name it gets converted to the code list ID.
 * 
 * @param {object} attributes 
 * @param {string} attributes.key_data_type_id if 'code_list_reference' then the code list with id in the property 'ref' is fetched
 * @param {string|number} attributes.ref id or key of the code_list to fetch
 * @param {array<string|number>} additionalKeys additional codeLists to fetch
 * @param {boolean} replaceListKeys replace list keys with ids if present in the attributes
 */

const getRefCodeListValues = async (attributes, additionalKeys = [], replaceListKeys = true) => {
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const listIds = [];
    const listKeys = [];
    const trefIds = [];
    const trefKeys = [];

    const _addKey = (type, ref) => {

        if (ref) {
            if (type === "code_list_reference" || type === 'code_list_reference_array') {
                if (!isNaN(parseInt(ref))) {
                    listIds.push(ref);
                }
                else {
                    listKeys.push(ref);
                }
            }
            else if (type === 'table_reference' || type === 'table_reference_array') {
                if (!isNaN(parseInt(ref))) {
                    trefIds.push(ref);
                }
                else {
                    trefKeys.push(ref);
                }
            }
        }
        
        if (type === 'reference') {
            listKeys.push('code_lists');
            listKeys.push('referenced_tables');
        }
    }

    attributes.map(v => _addKey(v.key_data_type_id, v.ref));

    additionalKeys.map(ref => _addKey('code_list_reference', ref));

    if (listIds.length === 0 && listKeys.length === 0 &&
        trefIds.length === 0 && trefKeys.length === 0) return;

    let requests = [];
    
    listIds.length > 0 ? 
        requests.push('code_list_options?:list_key_id=(' + listIds.join(',') + ')') :
        requests.push('');

    listKeys.length > 0 ? 
        requests.push(`code_list_options?:list_key=(${listKeys.join(',')})`) :
        requests.push('');

    requests.push(`code_list_options?:list_key=code_lists`);

    trefIds.length > 0 ? 
        requests.push('table_reference_values/language/null?:id=(' + trefIds.join(',') + ')') :
        requests.push('');

    trefKeys.length > 0 ? 
        requests.push(`table_reference_values/language/null?:id:code_list_options/key=(${trefKeys.join(',')})`) :
        requests.push('');

    requests.push(`code_list_options?:list_key=referenced_tables`);

    const res = await batchRequestHelper(requests);
    
    if (res === false) return [];

    const codeListValues = [...res[0], ...res[1]].map(clv => {
        clv.list_id = clv.list_key_id;
        return clv;
    });
    const tableReferences = [...res[3], ...res[4]];

    [...codeListValues, ...tableReferences].map(r => r.translations = r.translations ? JSON.parse(r.translations) : {});

    const codeLists = res[2];
    const trefs = res[5];

    if (replaceListKeys) {
        const codeListsObj = utils.arrayToObject(codeLists, 'key');
        const tableReferencesObj = utils.arrayToObject(trefs, 'key');
        attributes.map(a => {
            if (a.ref && isNaN(parseInt(a.ref))) {
                if (a.key_data_type_id === 'code_list_reference' || a.key_data_type_id === 'code_list_reference_array') {
                    a.ref = codeListsObj[a.ref].id;
                }
                else if (a.key_data_type_id === 'table_reference' || a.key_data_type_id === 'table_reference_array') {
                    a.ref = tableReferencesObj[a.ref].id;
                }
            }
        });
    }

    tableReferences.map(tr => tr._id_list_id = tr.id+'_'+tr.list_id);    //create unique identifiers
    
    return {codeListValues: codeListValues,
            codeLists: codeLists,
            trefs: trefs,
            tableReferences: tableReferences
    };
}

const validateConditionsForCompleteButton = function ($completeButton, bookmarks, cm) {
    if ($completeButton) {
        
        if (cm && cm.get('_status').val() == 3) {
            $completeButton && $completeButton.prop('disabled', false);
            return;
        }

        let sectionsValidated = true;
        const keys = Object.keys(bookmarks);
        for (let key of keys) {
            const bm = bookmarks[key].parent ? bookmarks[bookmarks[key].parent] : bookmarks[key];
            if (bm.required && !bm.validated) {
                if (['_odskodnina', '_odskodnina_additional'].indexOf(key) === -1) {
                    sectionsValidated = false;
                    break;
                }
            }
        }

        if (sectionsValidated && cm && cm.get('_status').val() != 3) { // [3, t`Obrazec 2.3 - vloga stranke`]
            if (cm && cm.get('_odskodnina').val().length===0 && cm.get('_odskodnina_additional').val().length===0) {
                sectionsValidated = false;
            }
        }

        $completeButton && $completeButton.prop('disabled', !sectionsValidated);
    }
}

const moduleHeader = function(title, extendedTitle, $btnGroup, $status=null, subtitle = null, $breadcrumbs = null, justifyContent='space-between') {
    const $container = $('<div/>');
    const $header = $('<div/>',{style: `display: flex; justify-content: ${justifyContent}; align-items: center`});
    extendedTitle = extendedTitle ? ': ' + `<span class="extended-title">${extendedTitle}</span>` : '';
    const $left = $('<div/>');

    $breadcrumbs && $left.append($breadcrumbs);

    $left.append(`<h2 class="mbase-title" style="margin-bottom:0">${title}${extendedTitle}</h2>`);
    subtitle && $left.append(`<h3 class="mbase-subtitle" style="margin-bottom:0">${subtitle}</h3>`);
    $header.append($left);
    $status && $header.append($status);
    $btnGroup && $header.append($btnGroup);
    $btnGroup && $btnGroup.css('margin-top','22px');
    $container.append($header);
    $container.append('<hr style="margin-bottom:0">');
    return $container;
}

const skipAttributes = (attributes, attributeKeysToBeSkipped) => attributes.filter(a => attributeKeysToBeSkipped.indexOf(a.key_name_id)===-1)

const generalTableRecordsOptions = async function  ($parent, tableName, moduleVariablesAttributes, codeListValues, tableReferences) {

    if (codeListValues !== undefined) { //check if codeListValues is structure holding codeListValues and/or tableReferences
        tableReferences = codeListValues.tableReferences || tableReferences;
        codeListValues = codeListValues.codeListValues || codeListValues;
    } 
    
    if (codeListValues=== undefined && tableReferences === undefined) {
        const refValues = await getRefCodeListValues(moduleVariablesAttributes);
        if (refValues) {
            codeListValues = refValues.codeListValues;
            tableReferences = refValues.tableReferences;
        }
    }

    return  {
        $parent: $parent,
        variablesAttributes: moduleVariablesAttributes,
        tableName: tableName,
        refValues: {codeListValues, tableReferences}
    }
}

const sortVariables = (variables, splitRequiredOptional = true) => {
    function compare( a, b ) {
        if ( a.weight < b.weight ){
          return -1;
        }
    
        if ( a.weight > b.weight ){
          return 1;
        }

        return 0;
    }

    if (splitRequiredOptional) {
        const required = [];
        const optional = [];

        variables.map(v => {
            if (v.required)  {
                required.push(v);
            }
            else {
                optional.push(v);
            }
        });    

        return [...required.sort(compare), ...optional.sort(compare)];
    }
    else {
        return variables.sort(compare);
    }
      
}

const moduleVariablesTableRecordsOptions = async function  ($parent, moduleId, moduleVariablesAttributes, codeListValues, tableReferences) {
    const generalOptions = await generalTableRecordsOptions($parent, 'module_variables', moduleVariablesAttributes, codeListValues, tableReferences);
    return  Object.assign(generalOptions, {
        select: [{
            key: 'module_id',
            value: moduleId
        }],
        skipAttributesFromTable: ['module_id'],
        url: _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot + `/module_variables/language/${_app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language}`
    });
};

const getRefValuesKey = variableAttributes => {
    let refValuesKey = null;
    if (['code_list_reference', 'reference', 'code_list_reference_array'].indexOf(variableAttributes.key_data_type_id) !==-1) {
        refValuesKey = 'codeListValues';
    }
    else if (variableAttributes.key_data_type_id === 'table_reference' || variableAttributes.key_data_type_id === 'table_reference_array') {
        refValuesKey = 'tableReferences';
    }

    return refValuesKey;
}

/**
 * returns relative file path with first two characters of file name as subfolder
 */
const filePath = (fileName) => {
    return '/m' + fileName.substring(0,2) + '/' + fileName;
}

/**
 * @param {object} target
 * @param {string} target.id id of the record to be updated, if undefined POST request will be sent
 * @param {object} target.attributes list of attributes to be sent with the request
 * @param {string} target.url url where a POST or PUT request will be sent
 */

const saveButtonHelper = async (source = {}) => {
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const t = utils.t;

    if (!source) source = {};
    
    return assignRequestCallbackToasters(Object.assign({
        request: utils.request,
        rootUrl: _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].apiRoot,
        upsertDataFunction: utils.upsertArray,
        loadingOverlayFunction: (show, $el) => loadingOverlay(show, $el)
    }, source));
}

const parseCenik = async rows => {
    const cenik = {};
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    rows.map(row => {
        cenik[[row.key_kategorija, row.key_podkategorija, row.key_objekt].filter(key => key).join(' > ')] = utils.jsonParse(row.cenik);
    });
    return cenik;
}

/**
 * 
 * @param {array<string>} keys keys in the price list (text property of individual item), keys are to be ordered in descending order as present in the price list
 * @param {object} priceList price list JSON object as stored in the database (array of objects in multi levels where text property is key)
 */

const findObjectPriceList = (keys,priceList) => {
    
    let items = priceList;

    for (const key of keys) {
        
        for (const item of items) {
            if (item.text === key) {
                items = item.nodes || item;
                break;
            }
        }
    }

    return items.cenik;
}

const assignRequestCallbackToasters = async (target) => {
    const t = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].t;
    return Object.assign(target, {
        onSuccess: (response, body) => $.toaster({ message : t`OK` }),
        onError: async (response, body) => $.toaster({ message : t`Error while saving` + ' ...<br>' + (await body).err, priority: 'danger' })
    });
}

const requestCallbacksHelper = (op = {}) => ({
    loadingOverlay: (show, $el) => loadingOverlay(show, op.$el || $el)
});

/**
 * Adds t_{key} property to individual items of array of objects if translation for 'key' exists
 */
const translateKey = (key, targetPropertyKey, aobj, codeListId, codeListValues, language = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].language) => {
    aobj.map(obj => {
        const clist = codeListValues.find(cl => cl.key === obj[key] && cl.list_id == codeListId);
        if (clist) {
            if (!obj[targetPropertyKey]) {
                obj[targetPropertyKey] = (clist.translations && clist.translations[language]) || clist.key;
            }
        }
    })
}

const getReferences = async (references, force=false) => {
    if (force === false && references) return references;
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    references = await batchRequestHelper(['code_lists', 'referenced_tables/language/null']);
    const rval = {};
    if (references !== false) {
        rval.code_list_reference = references[0].map(r => [r.id, r.label_key]);
        rval.table_reference = references[1].map(r => [r.id, r.key_id]);
    }
    return rval;
}

/**
 * 
 * @param {*} url 
 * @param {*} method 
 * @param {*} data 
 * @param {*} callbacks 
 * @param {*} $el jQuery DOM element for loading overlay 
 */

const requestHelper = async (url, method = 'GET', data = null, callbacks = {}, $el = null) => {
    const utils = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    return utils.request(url, method, data, Object.assign(requestCallbacksHelper({$el:$el}), callbacks));
}

/**
 * Returns patternfly html code for alert box
 * 
 * @param {*} msg 
 * @param {*} title 
 * @param {string} type alert box type: info, success, warning, danger
 * @returns {string} 
 */

const alertCode = (msg, title='', type='info') => {
    const types = {
        danger: {
            icon: "pficon-error-circle-o"
        },
        warning: {
            icon: "pficon-warning-triangle-o"
        },
        success: {
            icon: "pficon-ok"
        },
        info: {
            icon: "pficon-info"
        }
    };

    if (!types[type]) type = 'info';

    return `<div class="alert alert-${type}">
    <span class="pficon ${types[type].icon}"></span>
    <strong>${title}</strong> ${msg}
  </div>`;
}

/**
 * Returns priceLists index where valid_till field is more than examination date or empty
 * @param {*} examinationDate 
 * @param {*} priceLists 
 */
const dmgGetPriceListIndex = (examinationDate, priceLists) => {
    
    const examinationDateMoment = moment(examinationDate);
    let inx = priceLists.findIndex(plist => plist.valid_till && !examinationDateMoment.isAfter(plist.valid_till));
    
    if (inx === -1) {
        inx = priceLists.findIndex(plist => !plist.valid_till);
    }
    
    console.log('index', inx)
    
    return inx === -1 ? priceLists.length-1 : inx;
}

const dmgGetWorkHourPrices = (examinationDate, prices) => {
    const grouped = _.groupBy(prices, p=>p.valid_till);
    const examinationDateMoment = moment(examinationDate);

    console.log('examinationDAte', examinationDate)

    const filtered = prices.filter(p => p.valid_till && !examinationDateMoment.isAfter(p.valid_till));

    return filtered.length > 0 ? filtered : prices.filter(p => !p.valid_till);
}

const testData = async (apiRoot='') => {
    const u = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const codeList = await getCodeList('module_names', apiRoot);
    const virtualTables = await u.request(apiRoot + `/virtual-tables`);

    codeList.map(cl => {
        const vt = virtualTables.filter(vt => vt.label_key === cl.key);
        if (vt.length === 1) {
            u.request(apiRoot + '/virtual-table-values/modules', 'POST', {module_name: cl.id, properties:JSON.stringify([123])}).then(x=>console.log(x))
        }
        //
    })
}

const updateVTV = async (apiRoot='') => {
    const u = await Promise.resolve(/* import() */).then(__webpack_require__.bind(null, 8));
    const codeList = await getCodeList('module_names', apiRoot);
    const virtualTables = await u.request(apiRoot + `/virtual-tables`);

    codeList.map(cl => {
        const vt = virtualTables.filter(vt => vt.label_key === cl.key);
        if (vt.length === 1) {
            u.request(apiRoot + `/virtual-table-values/modules/${cl.id}`, 'PUT', {':properties':JSON.stringify([456])}).then(x=>console.log(x))
        }
        //
    })
}


/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponent", function() { return getComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePromises", function() { return resolvePromises; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select2value", function() { return select2value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select2text", function() { return select2text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patterns", function() { return patterns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hiddenInputs", function() { return hiddenInputs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processData", function() { return processData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upsertArray", function() { return upsertArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQueryParameter", function() { return getQueryParameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEavData", function() { return getEavData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getData", function() { return getData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hrefClick", function() { return hrefClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strLeftPad", function() { return strLeftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addKeysToComponents", function() { return addKeysToComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadComponents", function() { return loadComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadComponent", function() { return loadComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysInMonth", function() { return daysInMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidDate", function() { return isValidDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToAssocArray", function() { return convertToAssocArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBreadcrumbs", function() { return createBreadcrumbs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsonParse", function() { return jsonParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimSlash", function() { return trimSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rtrimSlash", function() { return rtrimSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyValueOutput", function() { return keyValueOutput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFloatContainersSideBySide", function() { return createFloatContainersSideBySide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "request", function() { return request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayToObject", function() { return arrayToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastItem", function() { return lastItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony import */ var _app_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);


const getComponent = (name, components) => {
    return components.filter(component => component[name])[0][name];
}

/**
 * Resolves promisses
 * @param {Object} promises Object with key - value pairs, where value is a Promise
 * @returns {Object} a promise of all input promises which - when resolved - returns Object with key - value pairs, where value is resolved input promise
 */
const resolvePromises = (promises) => {
    return Promise.all( Object.values(promises) ).then( resolved => 
        Object.keys(promises).reduce((obj, key, index) => ({ ...obj, [key]: resolved[index] }), {}) //combine input object keys with resolved results
    );
}

/**
 * Extracts selected item from Select2 callback parameter
 * @param {object} e select2 callback argument
 */
const select2value = e => {
    if (!e) return e;
    return (e.params && e.params.data) ? e.params.data.id : e;
}

const select2text = e => {
    if (!e) return e;
    return (e.params && e.params.data) ? e.params.data.text : e;
}

const patterns = {
    non_zero_integer: '^[1-9][0-9]+',
    any_letter_two_times: '\\p{L}{2}',
    _kadrovska_koda_pattern: '\\p{Lu}{2}[\\d\\p{Lu}]?',
    machine_key: '^[A-Z_][A-Z0-9_]+',
    real_number: '^\\d*\\.?\\d+$',
    email: '^[a-zA-Z0-9.!#$%&*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$',
    phone: '^[0][0-9]\\s*\\d(\\s*\\d){6,11}'
}

const hiddenInputs = keys => {
    return keys.map(key => 
        ({
            key: key, 
            required: true,
            validate: false
        })
    );
}

async function processData(data) {
    
    var values = data;

    if (data.fetch) {
        values = await request(data.fetch);
    }

    if (data.parse) {
        values = await data.parse(values);
    }

    return values;
}

const upsertArray = (arr, item, key = 'id') => {
    const variableIndex = arr.findIndex(v => v[key] == item[key]);

    if (variableIndex !== -1) {
        arr[variableIndex] = item;
    }
    else {
        arr.push(item);
    }
}

/**
 * https://stackoverflow.com/questions/2090551/parse-query-string-in-javascript
 * 
 * @param {string} variable variable to parse from query string
 */

const getQueryParameter = (variable) => {
    var query = window.location.search.substring(1);
    var vars = query.split('&');
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
        }
    }
}

async function getEavData(model, callback, apiRoot='') {

    const values = await request(apiRoot + `/virtual-table-values/${model.table}/language/${model.language}`);

    if (callback) {
        return await callback(values, model);
    }

    return values;
}

async function getData(model, apiRoot='') {

    let req;

    if (model.language) {
        req = `${model.table}/language/${model.language}`;
    }
    else {
        req = model.table;
    }

    const values = await request(apiRoot + '/' + req);

    return values;
}

function hrefClick(path, target = '_blank') {
    $(`<a href="${path}" ${target ? 'target='+target : ''}></a>`)[0].click();
}

/**
 * Pads input number with 
 * @param {integer | string} num 
 * @param {integer} size size of padded string
 * @param {string} [char = '0']  character to paddwith
 */

function strLeftPad(num, size, char = '0') {
    num = num.toString();
    if (!size) size = num.length;
    if (!size) return num;
    while (num.length < size) num = '0' + num;
    return num;
}

/**
 * https://www.sitepoint.com/testing-for-empty-values/
 * @param {*} data 
 * @returns true when data is:
 * - undefined or null
 * - a zero-length string
 * - an array with no members
 * - an object with no enumerable properties
 */

function empty(data)
{
  if(typeof(data) == 'number' || typeof(data) == 'boolean')
  { 
    return false; 
  }
  if(typeof(data) == 'undefined' || data === null)
  {
    return true; 
  }
  if(typeof(data.length) != 'undefined')
  {
    return data.length == 0;
  }
  var count = 0;
  for(var i in data)
  {
    if(data.hasOwnProperty(i))
    {
      count ++;
    }
  }
  return count == 0;
}

/**
 * Adds components object keys to object values
 * if object value is function it gets executed with a key as argument
 * 
 * @param {object} components 
 * @param {string} preposition
 */

const addKeysToComponents = (components, preposition = '') => {
    preposition = preposition && (preposition + '_'); //add an underscore if preposition is not empty
     
    Object.keys(components).map(key => {

        if (typeof components[key] === "function") {

            var proxied = components[key];
            components[key] = function() {
                const obj = proxied.apply( null, arguments );
                obj.key = preposition + key;
                return obj;
            };

        }
        else {
            components[key].key = preposition + key;
        }

    });  //add keys to components
}

/**
 * Adds a "key" property to the components defined in the first input argument and loads the components
 * 
 * @param {object} components 
 * @param {string} preposition preposition to be appended to a component key
 */

const loadComponents = (components, preposition = '') => {
    addKeysToComponents(components, preposition);
    return Promise.all(Object.keys(components).map(async key => {
        const component = components[key];
        if (component.module && typeof component.module === "function"){
            const impKey = component.import || 'default';
            component.component = (await component.module())[impKey];
        }
    }));
}

const loadComponent = async (key, component) => {
    if (component.module && typeof component.module === "function"){
        const impKey = component.import || 'default';
        component.component = (await component.module())[impKey];
    }
    component.key = key;
    return component;
}


/**
 * Get the number of days in any particular month
 * @link https://stackoverflow.com/a/1433119/1293256
 * @param  {integer} m The month (valid: 0-11)
 * @param  {integer} y The year
 * @return {integer}   The number of days in the month
 */
const daysInMonth = function (m, y) {
    switch (m) {
        case 1 :
            return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
        case 8 : case 3 : case 5 : case 10 :
            return 30;
        default :
            return 31
    }
};

/**
 * Check if a date is valid
 * @link https://stackoverflow.com/a/1433119/1293256
 * @param  {[type]}  d The day
 * @param  {[type]}  m The month
 * @param  {[type]}  y The year
 * @return {Boolean}   Returns true if valid
 */
const isValidDate = function (d, m, y) {
    m = parseInt(m, 10) - 1;
    return m >= 0 && m < 12 && d > 0 && d <= daysInMonth(m, y);
};

/**
 * Helper function: if array is passed it gets converted to object
 * @param {array|object} a 
 * @param {string} key 
 */
const convertToAssocArray = (a, key='id') => {
    if (a && Array.isArray(a)) {
        return arrayToObject(a, key);
    }
    return a;
}

const createBreadcrumbs = function(breadcrumbs) {
    const $ol = $('<ol class="breadcrumb" style="padding-bottom:0px"></ol>');
    for (let i=0; i<breadcrumbs.length; i++) {
        const bc = breadcrumbs[i];
        if (bc.class === 'active') {
            $ol.append(`<li class = "active"><strong>${bc.text}</strong></li>`);
        }
        else {
            $ol.append(`<li><a href="${bc.href}">${bc.text}</a></li>`);
        }
    }
    return $ol;
}

/**
 * Returns object form JSON string or object if argument is already an objevt
 * 
 * @param {string|object} json 
 */
const jsonParse = json => {
    if (typeof json !== 'object') {
        return JSON.parse(json);
    }

    return json;
}

const trimSlash = url => url.replace(/^\/+|\/+$/g, '');

const rtrimSlash = url => url.replace(/\/+$/g, '');

/**
 * A helper function to append key, value pairs to $el
 * @param {object} obj object of key values to putpur
 * @param {jquery DOM object} $el DOM element for the output
 * @param {object} keys iterate over keys provided in this parameter instead of all keys of the obj parameter
 * @param {array} keys.keys keys for the output
 * @param {object} keys.keyMap associative array obj.key 
 */
const keyValueOutput = (obj, $el, keys = null) => {
    const output = [];

    if (keys) {
        keys.keys.map(key => {
            const label = keys.keyMap[key];
            obj[label] && output.push(`<b>${label}:</b> ${obj[label]}`);    
        })
    }
    else {
        Object.keys(obj).map(label => {
            output.push(`<b>${label}:</b> ${obj[label]}`);
        });
    }

    $el.html(output.join('<br>'));
}

/**
 * Appends float left and float right container to $parent
 * @param {jQuery DOM object} $parent 
 */
const createFloatContainersSideBySide = $parent => {
    const $left =  $('<div style="float:  left;  width:49%;  overflow: auto"/>');
    const $right = $('<div style="float: right;  width:49%;  overflow: auto;"/>');
    $parent.append($left);
    $parent.append($right);
    $parent.append('<br style="clear:both">');

    return {
        $left: $left,
        $right: $right
    }
}


const fetchOptions = (op = {}) => Object.assign({
        method: 'GET', // *GET, POST, PUT, DELETE, etc.
        mode: 'cors', // no-cors, *cors, same-origin
        headers: { 'Content-Type': 'application/json', 'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content') },
        cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
        //credentials: 'same-origin', // include, *same-origin, omit
        redirect: 'follow', // manual, *follow, error
        referrerPolicy: 'no-referrer' // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    },op);

/**
 * Fetch API helper function with loading overlay option
 * 
 * @param {string} url 
 * @param {string} method request method in upercase 'GET', 'POST', 'PUT', 'DELETE', etc.
 * @param {object} data data to be sent with request (except for GET method, where the data should be put in the request's url)
 * @param {object} callbacks callback functions
 * @param {function} callbacks.loadingOverlay function with one argument, before the request it is invoked (if defined) with this argument set to true and after the request to false
 * @param {function} callbacks.onSuccess if defined called where response.ok === true
 * @param {function} callbacks.onError if defined called where response.ok === false
 * @param {object} _op fetchOptions overrides
 */

const request = async (url='', method = 'GET', data = null, callbacks = {}, _op = {}) => {
    
    const op = Object.assign({method: method}, _op);

    const loadingOverlayFunction = callbacks.loadingOverlay;

    const onSuccess = callbacks.onSuccess;

    const onError = callbacks.onError;

    if (data) {
        if (data instanceof File === true) {

            const formData = new FormData()
            formData.append('file', data, data.name);

            op.body = formData;
            op.headers = {};
        }
        else {
            op.body = JSON.stringify(data);
        }
    } 
    
    if (loadingOverlayFunction) loadingOverlayFunction(true);
    
    const response = await fetch(url, fetchOptions(op)).catch(e => {
        if (onError) onError({}, e);
    });
    
    if (loadingOverlayFunction) loadingOverlayFunction(false);

    if (response) {
        let parseResponse = 'text';
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            parseResponse = 'json';
        }
     
        const body = await response[parseResponse](); // parses JSON response into native JavaScript objects

        if (response.ok === true && onSuccess) onSuccess(response, body);
        if (response.ok === false && onError) onError(response, body);

        return response.ok === true ? body : false;
    }
    
    return false;
}

/**
 * Convert array of objects to associative object
 * @param {array<object>} arr 
 * @param {string} key the key in objects of input array to be used as associative key in the result
 */

const arrayToObject = (arr, key) => {
    if (!arr) return {};
    return arr.reduce((result, current) => {
        result[current[key]] = current;
        return result;
    }, {});
}

const lastItem = arr => {
    if (Array.isArray(arr) && arr.length>0) {
        return arr[arr.length-1];
    }
}

const t = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].t;


/***/ })

}]);