(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[1,75,96],{

/***/ 10:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _app_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_css__WEBPACK_IMPORTED_MODULE_3__);
/**
 * Helper function for DataTable component
 */

 
 
 
 
 
 /**
  * @param {object} op options
  * @param {object} op.$parent
  * @param {array} op.skipAttributesFromTable
  * @param {boolean} op.sortVariables
  * @param {array} op.variablesAttributes
  * @param {array} op.refValues
  * @param {function} op.onEditRecord   //opens ModalDialog with row data for editing
  * @param {function} op.externalEditRecord //only pass row data to externalEditRecord(row, rowId, rowIndex) function
  * @param {boolean} op.skipId
  * @param {function} op.preprocessTableData
  * @param {function} op.onTableCreated
  * @param {boolean} op.selectable //rows can be selected
  * @param {function} op.onRowSelected onRowSelected(data) where data is table row data
  * 
  * op.variables
  */
 /* harmony default export */ __webpack_exports__["default"] = (async op => {
     const [
         mutils,
         utils,
         Button,
         DataTable,
         ModalDialog,
         ButtonGroup,
         ComponentManager
     ] = await Promise.all([
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["mutils"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["utils"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["Button"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["DataTable"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["ModalDialog"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["ButtonGroup"](),
         _libs_exports__WEBPACK_IMPORTED_MODULE_0__["ComponentManager"]()
     ]);
 
     const {$parent} = op;
     const tableCm = op.cm || new ComponentManager.default();
 
     const {refValues} = op;
 
     const refValuesKeyed = await mutils.convertReferencesToAssocArray(refValues);
 
     if (op.select) {
         op.url = op.url + '?' + op.select.map(s => `:${s.key}=${s.value}`).join('&');
         tableCm.model.select = op.select;
     }
 
     tableCm.model.attributes = Object.assign([], op.variablesAttributes);
 
     //sort and filter out attributes that are not bound to database table
     const recordSetAttributes = op.variablesAttributes.filter(a => a.dbcolumn === true || a.dbcolumn === undefined);
 
     if (op.tableName && op.batchOptions && op.batchOptions.model && !op.batchOptions.model[op.tableName]) { //if batchOptions.model for the table is not defined it gets the value of recordsSetAttributes
         op.batchOptions.model[op.tableName] = [...recordSetAttributes];
     }
 
     const sortVariables = op.sortVariables === undefined ? true : op.sortVariables;
 
     if (sortVariables) {
         tableCm.model.attributes = mutils.sortVariables(tableCm.model.attributes, op.splitRequiredAndOptionalAttributesWhenSorting);
     }
     
     tableCm.model.tableName = op.tableName;
     
     const attributesObj = utils.arrayToObject(tableCm.model.attributes, 'key_name_id');
 
     const $buttonsContainer = $('<div class="flex-container"></div>');
 
     const components = {
         table: (op = {header:[], model:[]}) => ({
             component: DataTable.default,
             options: {
                 exportButtons: false,
                 scroller: true,
                 scrollX: true,
                 deferRender:true,
                 scrollY: op.scrollY || '75vh',
                 header: op.header,
                 onEdit: (rowData, rowId, rowIndex) => {
                     editRecord(rowData, rowId, rowIndex);
                 },
                 onDelete: (rowData, rowId) => {
                     deleteRow(rowData, rowId);
                 }
             },
             data: {
                 model: op.model,
                 process: processTableData,
                 refresh: (component, data) => {
                     component.setData(data);
                 }
             },
             beforeComponentCreate: options => {
                 const $div = $('<div/>');
                 $parent.append($div);
                 options.$container = $div;
             }
         }),
         btn_add_record:{
             component: Button.default,
             options: {
                 label: op.t && op.t.btn_add_record || _libs_utils__WEBPACK_IMPORTED_MODULE_2__["t"]`Add a record`,
                 style: op.btn_add_record && op.btn_add_record.style || 'width:100%',
                 type: op.btn_add_record && op.btn_add_record.type || 'btn-primary',
                 classes: op.btn_add_record && op.btn_add_record.classes,
                 onClick: () => editRecord()
             },
             $parent: op.btn_add_record || $buttonsContainer
         },
         btn_batch_import:{
             component: Button.default,
             options: {
                 label: _libs_utils__WEBPACK_IMPORTED_MODULE_2__["t"]`Batch import`,
                 style: 'width:100%',
                 type: 'btn-primary',
                 onClick: () => editRecords()
             },
             $parent: $buttonsContainer
         },
 
     };
 
     $parent.append($buttonsContainer);
 
     utils.addKeysToComponents(components);
 
     op.btn_add_record !== false && await tableCm.add(components.btn_add_record);
     op.btn_batch_import !== false && await tableCm.add(components.btn_batch_import);
 
     const btnAdd = tableCm.get('btn_add_record');
     const btnBatch = tableCm.get('btn_batch_import');
 
     const $btnAdd = btnAdd && btnAdd.$el();
     const $btnBatch = btnBatch && btnBatch.$el();
 
     op.btn_add_record === undefined && $btnAdd && $btnAdd.addClass('flex-child width15');
     $btnBatch && $btnBatch.addClass('flex-child width15');
     
     if (op.changeRecordSet) {
         op.changeRecordSet(onRecordSetChanged);
     }
     else {
         onRecordSetChanged();
     }
 
     //$btnAdd.find('button').click()
     //$btnBatch.find('button').click();
 
     function _op() {return op};   //to ensure we access most recent value for example in the callbacks that are attached in the initialisation
 
     async function deleteRow(data, row) {
         if (confirm(_libs_utils__WEBPACK_IMPORTED_MODULE_2__["t"]`Do you really want to delete selected row?`)) {
             const callbacks = await mutils.assignRequestCallbackToasters({});
             const res = await mutils.requestHelper((op.urlForDelete || op.url) + '/' + data.id, 'DELETE', null, callbacks);
             if (res!==false) {
                 row
                 .remove()
                 .draw();
             }
         }
     }
 
     async function editRecord(row, rowId, rowIndex) {
         const op = _op();
         if (op.externalEditRecord) {
             op.externalEditRecord(row, rowId, rowIndex);
             return;
         }
         const cm = new ComponentManager.default();
         cm.model = Object.assign({}, op.editRecordModel || tableCm.model);
         cm.model.attributes = (op.editRecordModel && op.editRecordModel.attributes) || recordSetAttributes;
         
         if (row!==undefined) {
             const data = tableCm.getData('table').find(r => r.id == row.id);
             if (!data) return;
             
             const attributes = utils.convertToAssocArray(recordSetAttributes, 'key_name_id');
 
             const values = {};
 
             Object.keys(data).map(key => {
                 const a = attributes[key];
                 let value = data[key];
                 if (a && a.key_data_type_id === 'json') {
                     value = utils.jsonParse(value);
                 }
                 values[key] = value;
             });
             cm.model.values = values;
         }
 
         let _continue = true;
         if (op.onEditRecord) {
             _continue = op.onEditRecord(cm, row); //pass records components to parent
         }
 
         if (_continue === false) return false;
 
         const record = await _libs_exports__WEBPACK_IMPORTED_MODULE_0__["record"]();
         const modal = new ModalDialog.default({
             onShown: () => {
 
                 const saveOptions = op.saveOptions || {};
 
                 //add callback to other possibly defined callbacks
                 if (!saveOptions.onSuccessCallbacks) {
                     saveOptions.onSuccessCallbacks = [];
                 }
                 saveOptions.onSuccessCallbacks.push(onRecordUpserted);  
 
                 record.default({
                     $parent: modal,
                     cm: cm,
                     saveOptions: saveOptions,
                     refValues: op.refValues,
                     onInit: function () {
                         const args = Array.prototype.slice.call(arguments);
                         args.push(modal);
                         op.onInitRecord && op.onInitRecord.apply(null, args);
                     },
                     onSuccessfullySaved: (cm, result, model) => {
                         op.onSuccessfullySaved && op.onSuccessfullySaved(cm, result, model);
                         modal.hide();
                     }
                 });
             }
         });
         modal.show();
     }
 
     async function editRecords() {
         const op = _op();
 
         const batchModel = op.batchOptions && op.batchOptions.model;
 
         if (!batchModel) return;
 
         const batch = await __webpack_require__.e(/* import() */ 76).then(__webpack_require__.bind(null, 13));
         const modal = new ModalDialog.default();
             
             batch.default(Object.assign({
                 $parent: modal,
                 model: batchModel,
                 tableName: op.tableName,
                 refValues: op.refValues,
                 modal:modal
             }));
 
         modal.show();
         
     }
 
     async function onRecordSetChanged(dataValues = null) {
         const op = _op();
         tableCm.destroy('table');
 
         const skipAttributesFromTable = op.skipAttributesFromTable || [];
 
         const idcol = op.skipId ? [] : [{key: 'id', label: 'id'}];
 
         const header = [...idcol, ...(op.tableAttributesOverride || tableCm.model.attributes).filter(a => skipAttributesFromTable.findIndex(key => key === a.key_name_id)===-1).map(d => {
 
             if (op.tableAttributesOverride && !d.t_name_id) {
                 const attributeDefinition = attributesObj[d.key_name_id];
                 d.t_name_id = attributeDefinition && attributeDefinition.t_name_id;
             }
 
             //translate the folowing data types (DataTables component fills rows according to the header key value):
             const key = ['code_list_reference','table_reference','reference','location_reference','table_reference_array', 'code_list_reference_array'].indexOf(d.key_data_type_id) === -1 ? d.key_name_id : 't_' + d.key_name_id;
             
             return {
                 key: key,
                 label: d.t_name_id || d.key_name_id
             }}
         )];
 
         const tableDataModel = {
             keys: header.map(h => h.key),
             url: op.url
         }
 
         const tableDefinition = components.table({header, model:tableDataModel});   //defaultOptions
 
         if (op.data && op.data.values) {
             tableDefinition.data.values = op.data.values;
         }
         else if (dataValues) {
             tableDefinition.data.values = dataValues;
         }
         else {
             tableDefinition.data.request = model => mutils.requestHelper(model.url);
         }
         
         if (op.disableEdit) {
             delete tableDefinition.options['onEdit'];
         }
 
         if (op.preprocessTableData) {
             tableDefinition.data.preprocess = op.preprocessTableData;
         }
 
         tableDefinition.options = Object.assign(tableDefinition.options, op.tableOptions || {});
 
         if (_app_globals__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].language === 'sl') {
             tableDefinition.options.language = await __webpack_require__.e(/* import() */ 52).then(__webpack_require__.t.bind(null, 36, 3));
         }
 
         tableDefinition.options.deletable = op.deletable;
         tableDefinition.options.rowEditOptions = op.rowEditOptions;
 
         if (op.selectable || op.onRowSelected) {
             tableDefinition.options.select = true;
             if (op.onRowSelected) {
                 tableDefinition.options.onRowSelected = op.onRowSelected;
             }
         }
 
 
         /*
         const SearchInput = await import('../../components/SearchInput');
         tableDefinition.options.customSearchInput = {
             Constructor: SearchInput.default,
             options: Object.assign({
                 placeholder: t`Search`
             }, op.searchInputOptions || {})
         };
         */
 
         if (op.cellEdit) {
             tableDefinition.options.keys=op.cellEdit.keys || true;
         }
 
         const table = await tableCm.add(tableDefinition);
 
         /**
          * this was a "hack" and remains here for backward compatibility - the way to get access to these functions is by using returned object from this helper
          */
         table.__editRecord = editRecord;    
         table.__editRecords = editRecords;
 
         if (tableDefinition.options.keys) {
             const tableKeys = await __webpack_require__.e(/* import() */ 97).then(__webpack_require__.bind(null, 37));
             tableKeys.default(table, table.getHeaderKeys(), op.cellEdit);
         }
 
         if (op.tableOptions && op.tableOptions.select) {
 
             const actionsBtn = new ButtonGroup.default({
                 buttons: [
                     {
                         key: 'select_all',
                         label: _libs_utils__WEBPACK_IMPORTED_MODULE_2__["t"]`Select all`
                     },
                     {
                         key: 'select_none',
                         label: _libs_utils__WEBPACK_IMPORTED_MODULE_2__["t"]`Select none`
                     }/*,
                     {
                         key: 'edit',
                         label: '<a href="#" class="table-action"><span class="fa fa-edit"></span></a>'
                     }*/
                 ],
                 classes: 'btn btn-default',
                 onClick: (data, key) => {
                     if (key==='select_all') {
                         table.table.rows({ search: 'applied' }).select();
                     }
                     else if (key==='select_none') {
                         table.table.rows().deselect();
                     }
                     else if (key==='edit') {
 
                     }
                 },
                 highlight: false
             });
 
             
             const $wrapper = table.$el().parents('.dataTables_wrapper:first');
             const $div = $('<div/>',{style: "display: inline-flex"});
             $div.append(actionsBtn.$el());
             $wrapper.prepend($div);
         }
 
         
         if (op.onTableCreated) {
             op.onTableCreated(tableCm.get('table'), tableCm.getData('table'));
         }
 
         if (op.onRecordSetChanged) {
             op.onRecordSetChanged(tableCm.getData('table'));
         }        
     }
 
     function processTableData(data, model) {
         const op = _op();
         return data.map((row, inx) => {
             mutils.processAttributeValues(row, attributesObj, refValuesKeyed);
 
             //add keys if they are not present in the structure
             model.keys.map(key => {
                 if (row[key] === undefined) row[key] = null;
             })
             
             if (op.processTableData) {
                 row = op.processTableData(row, inx);
             }
 
             row.__rowInx = inx;
             return row;
         });
     }
 
     function onRecordUpserted(_cm, model) {
         const modelArray = Array.isArray(model) ? model : [model];
         modelArray.map(m => utils.upsertArray(tableCm.getData('table'), m));
         tableCm.refresh('table');
         op.onRecordSetUpserted && op.onRecordSetUpserted(model, tableCm.get('table'));
     }
 
     return Object.freeze({
         editRecord: editRecord,
         editRecords: editRecords
     });
 }); 
 

/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponent", function() { return getComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePromises", function() { return resolvePromises; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select2value", function() { return select2value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select2text", function() { return select2text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patterns", function() { return patterns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hiddenInputs", function() { return hiddenInputs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processData", function() { return processData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upsertArray", function() { return upsertArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQueryParameter", function() { return getQueryParameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEavData", function() { return getEavData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getData", function() { return getData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hrefClick", function() { return hrefClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strLeftPad", function() { return strLeftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addKeysToComponents", function() { return addKeysToComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadComponents", function() { return loadComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadComponent", function() { return loadComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysInMonth", function() { return daysInMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidDate", function() { return isValidDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToAssocArray", function() { return convertToAssocArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBreadcrumbs", function() { return createBreadcrumbs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsonParse", function() { return jsonParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimSlash", function() { return trimSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rtrimSlash", function() { return rtrimSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyValueOutput", function() { return keyValueOutput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFloatContainersSideBySide", function() { return createFloatContainersSideBySide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "request", function() { return request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayToObject", function() { return arrayToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastItem", function() { return lastItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony import */ var _app_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);


const getComponent = (name, components) => {
    return components.filter(component => component[name])[0][name];
}

/**
 * Resolves promisses
 * @param {Object} promises Object with key - value pairs, where value is a Promise
 * @returns {Object} a promise of all input promises which - when resolved - returns Object with key - value pairs, where value is resolved input promise
 */
const resolvePromises = (promises) => {
    return Promise.all( Object.values(promises) ).then( resolved => 
        Object.keys(promises).reduce((obj, key, index) => ({ ...obj, [key]: resolved[index] }), {}) //combine input object keys with resolved results
    );
}

/**
 * Extracts selected item from Select2 callback parameter
 * @param {object} e select2 callback argument
 */
const select2value = e => {
    if (!e) return e;
    return (e.params && e.params.data) ? e.params.data.id : e;
}

const select2text = e => {
    if (!e) return e;
    return (e.params && e.params.data) ? e.params.data.text : e;
}

const patterns = {
    non_zero_integer: '^[1-9][0-9]+',
    any_letter_two_times: '\\p{L}{2}',
    _kadrovska_koda_pattern: '\\p{Lu}{2}[\\d\\p{Lu}]?',
    machine_key: '^[A-Z_][A-Z0-9_]+',
    real_number: '^\\d*\\.?\\d+$',
    email: '^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$',
    phone: '^[0][0-9]\\s*\\d(\\s*\\d){6,11}'
}

const hiddenInputs = keys => {
    return keys.map(key => 
        ({
            key: key, 
            required: true,
            validate: false
        })
    );
}

async function processData(data) {
    
    var values = data;

    if (data.fetch) {
        values = await request(data.fetch);
    }

    if (data.parse) {
        values = await data.parse(values);
    }

    return values;
}

const upsertArray = (arr, item, key = 'id') => {
    const variableIndex = arr.findIndex(v => v[key] == item[key]);

    if (variableIndex !== -1) {
        arr[variableIndex] = item;
    }
    else {
        arr.push(item);
    }
}

/**
 * https://stackoverflow.com/questions/2090551/parse-query-string-in-javascript
 * 
 * @param {string} variable variable to parse from query string
 */

const getQueryParameter = (variable) => {
    var query = window.location.search.substring(1);
    var vars = query.split('&');
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
        }
    }
}

async function getEavData(model, callback, apiRoot='') {

    const values = await request(apiRoot + `/virtual-table-values/${model.table}/language/${model.language}`);

    if (callback) {
        return await callback(values, model);
    }

    return values;
}

async function getData(model, apiRoot='') {

    let req;

    if (model.language) {
        req = `${model.table}/language/${model.language}`;
    }
    else {
        req = model.table;
    }

    const values = await request(apiRoot + '/' + req);

    return values;
}

function hrefClick(path, target = '_blank') {
    $(`<a href="${path}" ${target ? 'target='+target : ''}></a>`)[0].click();
}

/**
 * Pads input number with 
 * @param {integer | string} num 
 * @param {integer} size size of padded string
 * @param {string} [char = '0']  character to paddwith
 */

function strLeftPad(num, size, char = '0') {
    num = num.toString();
    if (!size) size = num.length;
    if (!size) return num;
    while (num.length < size) num = '0' + num;
    return num;
}

/**
 * https://www.sitepoint.com/testing-for-empty-values/
 * @param {*} data 
 * @returns true when data is:
 * - undefined or null
 * - a zero-length string
 * - an array with no members
 * - an object with no enumerable properties
 */

function empty(data)
{
  if(typeof(data) == 'number' || typeof(data) == 'boolean')
  { 
    return false; 
  }
  if(typeof(data) == 'undefined' || data === null)
  {
    return true; 
  }
  if(typeof(data.length) != 'undefined')
  {
    return data.length == 0;
  }
  var count = 0;
  for(var i in data)
  {
    if(data.hasOwnProperty(i))
    {
      count ++;
    }
  }
  return count == 0;
}

/**
 * Adds components object keys to object values
 * if object value is function it gets executed with a key as argument
 * 
 * @param {object} components 
 * @param {string} preposition
 */

const addKeysToComponents = (components, preposition = '') => {
    preposition = preposition && (preposition + '_'); //add an underscore if preposition is not empty
     
    Object.keys(components).map(key => {

        if (typeof components[key] === "function") {

            var proxied = components[key];
            components[key] = function() {
                const obj = proxied.apply( null, arguments );
                obj.key = preposition + key;
                return obj;
            };

        }
        else {
            components[key].key = preposition + key;
        }

    });  //add keys to components
}

/**
 * Adds a "key" property to the components defined in the first input argument and loads the components
 * 
 * @param {object} components 
 * @param {string} preposition preposition to be appended to a component key
 */

const loadComponents = (components, preposition = '') => {
    addKeysToComponents(components, preposition);
    return Promise.all(Object.keys(components).map(async key => {
        const component = components[key];
        if (component.module && typeof component.module === "function"){
            const impKey = component.import || 'default';
            component.component = (await component.module())[impKey];
        }
    }));
}

const loadComponent = async (key, component) => {
    if (component.module && typeof component.module === "function"){
        const impKey = component.import || 'default';
        component.component = (await component.module())[impKey];
    }
    component.key = key;
    return component;
}


/**
 * Get the number of days in any particular month
 * @link https://stackoverflow.com/a/1433119/1293256
 * @param  {integer} m The month (valid: 0-11)
 * @param  {integer} y The year
 * @return {integer}   The number of days in the month
 */
const daysInMonth = function (m, y) {
    switch (m) {
        case 1 :
            return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
        case 8 : case 3 : case 5 : case 10 :
            return 30;
        default :
            return 31
    }
};

/**
 * Check if a date is valid
 * @link https://stackoverflow.com/a/1433119/1293256
 * @param  {[type]}  d The day
 * @param  {[type]}  m The month
 * @param  {[type]}  y The year
 * @return {Boolean}   Returns true if valid
 */
const isValidDate = function (d, m, y) {
    m = parseInt(m, 10) - 1;
    return m >= 0 && m < 12 && d > 0 && d <= daysInMonth(m, y);
};

/**
 * Helper function: if array is passed it gets converted to object
 * @param {array|object} a 
 * @param {string} key 
 */
const convertToAssocArray = (a, key='id') => {
    if (a && Array.isArray(a)) {
        return arrayToObject(a, key);
    }
    return a;
}

const createBreadcrumbs = function(breadcrumbs) {
    const $ol = $('<ol class="breadcrumb" style="padding-bottom:0px"></ol>');
    for (let i=0; i<breadcrumbs.length; i++) {
        const bc = breadcrumbs[i];
        if (bc.class === 'active') {
            $ol.append(`<li class = "active"><strong>${bc.text}</strong></li>`);
        }
        else {
            $ol.append(`<li><a href="${bc.href}">${bc.text}</a></li>`);
        }
    }
    return $ol;
}

/**
 * Returns object form JSON string or object if argument is already an objevt
 * 
 * @param {string|object} json 
 */
const jsonParse = json => {
    if (typeof json !== 'object') {
        return JSON.parse(json);
    }

    return json;
}

const trimSlash = url => url.replace(/^\/+|\/+$/g, '');

const rtrimSlash = url => url.replace(/\/+$/g, '');

/**
 * A helper function to append key, value pairs to $el
 * @param {object} obj object of key values to putpur
 * @param {jquery DOM object} $el DOM element for the output
 * @param {object} keys iterate over keys provided in this parameter instead of all keys of the obj parameter
 * @param {array} keys.keys keys for the output
 * @param {object} keys.keyMap associative array obj.key 
 */
const keyValueOutput = (obj, $el, keys = null) => {
    const output = [];

    if (keys) {
        keys.keys.map(key => {
            const label = keys.keyMap[key];
            obj[label] && output.push(`<b>${label}:</b> ${obj[label]}`);    
        })
    }
    else {
        Object.keys(obj).map(label => {
            output.push(`<b>${label}:</b> ${obj[label]}`);
        });
    }

    $el.html(output.join('<br>'));
}

/**
 * Appends float left and float right container to $parent
 * @param {jQuery DOM object} $parent 
 */
const createFloatContainersSideBySide = $parent => {
    const $left =  $('<div style="float:  left;  width:49%;  overflow: auto"/>');
    const $right = $('<div style="float: right;  width:49%;  overflow: auto;"/>');
    $parent.append($left);
    $parent.append($right);
    $parent.append('<br style="clear:both">');

    return {
        $left: $left,
        $right: $right
    }
}


const fetchOptions = (op = {}) => Object.assign({
        method: 'GET', // *GET, POST, PUT, DELETE, etc.
        mode: 'cors', // no-cors, *cors, same-origin
        headers: { 'Content-Type': 'application/json', 'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content') },
        cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
        //credentials: 'same-origin', // include, *same-origin, omit
        redirect: 'follow', // manual, *follow, error
        referrerPolicy: 'no-referrer' // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    },op);

/**
 * Fetch API helper function with loading overlay option
 * 
 * @param {string} url 
 * @param {string} method request method in upercase 'GET', 'POST', 'PUT', 'DELETE', etc.
 * @param {object} data data to be sent with request (except for GET method, where the data should be put in the request's url)
 * @param {object} callbacks callback functions
 * @param {function} callbacks.loadingOverlay function with one argument, before the request it is invoked (if defined) with this argument set to true and after the request to false
 * @param {function} callbacks.onSuccess if defined called where response.ok === true
 * @param {function} callbacks.onError if defined called where response.ok === false
 * @param {object} _op fetchOptions overrides
 */

const request = async (url='', method = 'GET', data = null, callbacks = {}, _op = {}) => {
    
    const op = Object.assign({method: method}, _op);

    const loadingOverlayFunction = callbacks.loadingOverlay;

    const onSuccess = callbacks.onSuccess;

    const onError = callbacks.onError;

    if (data) {
        if (data instanceof File === true) {

            const formData = new FormData()
            formData.append('file', data, data.name);

            op.body = formData;
            op.headers = {};
        }
        else {
            op.body = JSON.stringify(data);
        }
    } 
    
    if (loadingOverlayFunction) loadingOverlayFunction(true);
    
    const response = await fetch(url, fetchOptions(op)).catch(e => {
        if (onError) onError({}, e);
    });
    
    if (loadingOverlayFunction) loadingOverlayFunction(false);

    if (response) {
        let parseResponse = 'text';
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            parseResponse = 'json';
        }
     
        const body = await response[parseResponse](); // parses JSON response into native JavaScript objects

        if (response.ok === true && onSuccess) onSuccess(response, body);
        if (response.ok === false && onError) onError(response, body);

        return response.ok === true ? body : false;
    }
    
    return false;
}

/**
 * Convert array of objects to associative object
 * @param {array<object>} arr 
 * @param {string} key the key in objects of input array to be used as associative key in the result
 */

const arrayToObject = (arr, key) => {
    if (!arr) return {};
    return arr.reduce((result, current) => {
        result[current[key]] = current;
        return result;
    }, {});
}

const lastItem = arr => {
    if (Array.isArray(arr) && arr.length>0) {
        return arr[arr.length-1];
    }
}

const t = _app_globals__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].t;


/***/ })

}]);